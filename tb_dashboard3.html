<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beverage Orders Dashboard</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      .order-note-display {
        background: #f9fafb;
        border-left: 3px solid #667eea;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 13px;
        color: #374151;
        margin: 10px 0;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background: linear-gradient(135deg, #3a3a3a 0%, #000000 100%);
        min-height: 100vh;
        color: #1a1a1a;
      }

      .dashboard-container {
        min-height: 100vh;
        padding: 20px;
      }

      .header {
        background: white;
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: between;
        align-items: center;
        flex-wrap: wrap;
        gap: 16px;
      }

      .header-left {
        flex: 1;
      }

      .dashboard-title {
        font-size: 28px;
        font-weight: 800;
        color: #1a1a1a;
        margin-bottom: 8px;
        letter-spacing: -0.5px;
      }

      .dashboard-subtitle {
        color: #6b7280;
        font-size: 16px;
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background: #10b981;
        color: white;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 600;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        background: currentColor;
        border-radius: 50%;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .controls {
        background: white;
        border-radius: 16px;
        padding: 24px;
        margin-bottom: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .controls-row {
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-group label {
        font-size: 14px;
        font-weight: 600;
        color: #4a4a4a;
      }

      select,
      input {
        padding: 12px 16px;
        border: 2px solid #e5e5e5;
        border-radius: 8px;
        font-size: 14px;
        outline: none;
        transition: all 0.2s ease;
        background: white;
      }

      select:focus,
      input:focus {
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }

      .refresh-btn,
      .clear-btn {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
      }

      .refresh-btn {
        background: linear-gradient(135deg, #66ea9f 0%, #4ba274 100%);
        color: white;
      }

      .refresh-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 234, 172, 0.3);
      }

      .clear-btn {
        background: #ef4444;
        color: white;
      }

      .clear-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 24px;
      }

      .stat-card {
        background: white;
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        text-align: center;
        transition: all 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      }

      .stat-number {
        font-size: 32px;
        font-weight: 800;
        color: #667eea;
        margin-bottom: 8px;
      }

      .stat-label {
        font-size: 14px;
        color: #6b7280;
        font-weight: 600;
      }

      .orders-container {
        background: white;
        border-radius: 16px;
        padding: 24px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .orders-header {
        display: flex;
        justify-content: between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 2px solid #f0f0f0;
      }

      .orders-title {
        font-size: 20px;
        font-weight: 700;
        color: #1a1a1a;
      }

      .orders-count {
        background: #667eea;
        color: white;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
      }

      .orders-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-height: 600px;
        overflow-y: auto;
      }

      .order-card {
        border: 2px solid #f0f0f0;
        border-radius: 12px;
        padding: 20px;
        /* transition: all 0.3s ease; */
        position: relative;
      }

      .order-card:hover {
        border-color: #667eea;
        /* transform: translateX(4px); */
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.1);
      }

      .order-card.pending {
        border-left: 4px solid #f59e0b;
        background: linear-gradient(135deg, #fefbf5 0%, #fef9f0 100%);
      }

      .order-card.in-progress {
        border-left: 4px solid #3b82f6;
        background: linear-gradient(135deg, #f7f9ff 0%, #f0f4ff 100%);
      }

      .order-card.completed {
        border-left: 4px solid #10b981;
        background: linear-gradient(135deg, #f7fef9 0%, #f0fff4 100%);
      }

      .order-header {
        display: flex;
        justify-content: between;
        align-items: flex-start;
        margin-bottom: 16px;
      }

      .order-info {
        flex: 1;
      }

      .order-id {
        font-size: 18px;
        font-weight: 700;
        color: #1a1a1a;
        margin-bottom: 4px;
      }

      .order-meta {
        font-size: 14px;
        color: #6b7280;
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
      }

      .order-status {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .order-status.pending {
        background: #f59e0b;
        color: white;
      }

      .order-status.in-progress {
        background: #3b82f6;
        color: white;
      }

      .order-status.completed {
        background: #10b981;
        color: white;
      }

      .order-items {
        margin-bottom: 16px;
      }

      .items-title {
        font-size: 14px;
        font-weight: 600;
        color: #4a4a4a;
        margin-bottom: 8px;
      }

      .items-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .item-tag {
        background: #667eea;
        color: white;
        padding: 4px 12px;
        border-radius: 16px;
        font-size: 13px;
        font-weight: 500;
      }

      .order-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .action-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .start-btn {
        background: #3b82f6;
        color: white;
      }

      .complete-btn {
        background: #10b981;
        color: white;
      }

      .delete-btn {
        background: #ef4444;
        color: white;
      }

      .action-btn:hover {
        transform: translateY(-1px);
        opacity: 0.9;
      }

      .empty-state {
        text-align: center;
        padding: 60px 20px;
        color: #6b7280;
      }

      .empty-state svg {
        width: 64px;
        height: 64px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .empty-state h3 {
        font-size: 18px;
        margin-bottom: 8px;
      }

      .empty-state p {
        font-size: 14px;
      }

      .notification {
        position: fixed;
        top: 20px;
        right: -400px;
        background: white;
        border-radius: 12px;
        padding: 16px 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        transition: right 0.3s ease;
        z-index: 1000;
        border-left: 4px solid #10b981;
      }

      .notification.show {
        right: 20px;
      }

      .notification-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .notification-message {
        font-size: 14px;
        color: #6b7280;
      }

      @media (max-width: 768px) {
        .dashboard-container {
          padding: 16px;
        }

        .header {
          text-align: center;
        }

        .header-right {
          width: 100%;
          justify-content: center;
        }

        .controls-row {
          flex-direction: column;
          align-items: stretch;
        }

        .control-group {
          width: 100%;
        }

        .refresh-btn,
        .clear-btn {
          width: 100%;
        }

        .stats {
          grid-template-columns: repeat(2, 1fr);
        }

        .order-meta {
          flex-direction: column;
          gap: 8px;
        }

        .order-header {
          flex-direction: column;
          gap: 12px;
        }

        .order-actions {
          width: 100%;
        }

        .action-btn {
          flex: 1;
        }
      }

      .tiny-btn {
        padding: 8px 12px;
        border-radius: 10px;
        font-size: 12px;
        font-weight: 700;
        border: 1px solid #e5e7eb;
        background: #ffffff;
        color: #111827;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .tiny-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }
      body.dashboard-company .tiny-btn {
        border-color: #e0e7ff;
        background: #f8f9ff;
        color: #111827;
      }
    </style>
  </head>
  <body>
    <div class="dashboard-container">
      <div class="header">
        <div class="header-left">
          <h1 class="dashboard-title">TeaBoy Beverage Orders Dashboard # 3</h1>
          <p class="dashboard-subtitle">Corporate Beverage Solutions</p>
        </div>
        <div class="header-right">
          <!-- <button
            id="deskSettingsBtn"
            class="tiny-btn"
            title="Configure desks"
            onclick="goToSettings()"
          >
            Desk Settings
          </button> -->
          <div class="status-indicator">
            <span class="status-dot"></span>
            <span>Live Updates</span>
          </div>
        </div>
      </div>

      <!-- Add this before closing </body> -->
      <audio id="notificationSound" preload="auto">
        <source src="ding.mp3" type="audio/mpeg" />
        <!-- <source src="noti_saf.mp3" type="audio/mpeg" /> -->
      </audio>

      <div class="controls">
        <div class="controls-row">
          <div class="control-group">
            <label for="statusFilter">Filter by Status</label>
            <select id="statusFilter">
              <option value="all">All Orders</option>
              <option value="pending">Pending</option>
              <option value="in-progress">In Progress</option>
              <option value="completed">Completed</option>
            </select>
          </div>
          <div class="control-group">
            <label for="deskFilter">Filter by Desk</label>
            <input
              type="number"
              id="deskFilter"
              placeholder="Enter desk number"
              min="1"
            />
          </div>
          <div class="control-group">
            <label>&nbsp;</label>
            <button class="refresh-btn" id="refreshBtn">Refresh Orders</button>
          </div>
          <!-- <div class="control-group">
            <label>&nbsp;</label>
            <button class="clear-btn" id="clearBtn">Clear All Orders</button>
          </div> -->
        </div>
      </div>

      <div class="orders-container">
        <div class="orders-header">
          <h2 class="orders-title">Recent Orders</h2>
          <span class="orders-count" id="ordersCount">0 orders</span>
        </div>
        <div class="orders-list" id="ordersList">
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path
                d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1ZM10 6a2 2 0 0 1 4 0v1h-4V6Zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10Z"
              />
            </svg>
            <h3>No orders yet</h3>
            <p>Orders will appear here as they come in</p>
          </div>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <div class="notification-title" id="notificationTitle">New Order!</div>
      <div class="notification-message" id="notificationMessage">
        <!-- Order received from Desk #1 -->
      </div>
    </div>

    <script>
      function goToSettings() {
        window.location.href = "/settings";
      }

      function unlockAudio() {
        const sound = document.getElementById("notificationSound");
        if (!sound) return;
        sound.volume = 1.0;
        sound
          .play()
          .then(() => {
            sound.pause();
            sound.currentTime = 0;
            console.log("🔔 Audio unlocked and ready");
          })
          .catch((err) => console.warn("Unlock failed:", err));
      }

      window.addEventListener("click", unlockAudio, { once: true });
      window.addEventListener("keydown", unlockAudio, { once: true });

      // class DashboardApp {
      //   constructor() {
      //     this.orders = [];
      //     this.filteredOrders = [];
      //     // this.apiEndpoint = "http://localhost:4000/api/orders";
      //     this.apiEndpoint = "https://ordersystembysaflink.online/api/orders";

      //     // === Set your allowed desk range here ===
      //     this.startDesk = 78;
      //     this.endDesk = 102;

      //     // Precompute helpers for quick checks
      //     this.allowedDesks = this.buildAllowedDeskSet();

      //     this.pollInterval = null;
      //     this.init();
      //   }

      //   // Build a set with "1","2",... and "DESK1","desk1" for quick membership checks
      //   buildAllowedDeskSet() {
      //     const set = new Set();
      //     for (let i = this.startDesk; i <= this.endDesk; i++) {
      //       set.add(String(i));
      //       set.add(`DESK${i}`);
      //       set.add(`desk${i}`);
      //     }
      //     return set;
      //   }

      //   // Extract numeric desk from either `desk` or `serviceArea` (supports "DESK12" etc.)
      //   getDeskNumber(order) {
      //     const d = order?.desk != null ? String(order.desk).trim() : "";
      //     if (/^\d+$/.test(d)) return parseInt(d, 10);

      //     const sa =
      //       order?.serviceArea != null ? String(order.serviceArea).trim() : "";
      //     const m = sa.match(/desk\s*([0-9]+)/i);
      //     if (m) return parseInt(m[1], 10);

      //     return null;
      //   }

      //   // True if order belongs to the allowed desk range
      //   isDeskInAllowedRange(order) {
      //     const n = this.getDeskNumber(order);
      //     if (n != null) return n >= this.startDesk && n <= this.endDesk;

      //     // fallback: if only raw strings are available, check set membership
      //     const d = order?.desk != null ? String(order.desk).trim() : "";
      //     const sa =
      //       order?.serviceArea != null ? String(order.serviceArea).trim() : "";
      //     return this.allowedDesks.has(d) || this.allowedDesks.has(sa);
      //   }

      //   // Convenience: only the orders within the allowed range
      //   getOrdersInRange() {
      //     return this.orders.filter((o) => this.isDeskInAllowedRange(o));
      //   }

      //   init() {
      //     this.loadOrders();
      //     this.attachEventListeners();
      //     this.startPolling();
      //     this.updateStats();
      //   }

      class DashboardApp {
        constructor() {
          this.orders = [];
          this.filteredOrders = [];
          // this.apiEndpoint = "https://ordersystembysaflink.online/api/orders";

          // === Define your desk range here ===
          this.startDesk = 78;
          this.endDesk = 102;

          this.firstLoad = true;

          // === Define custom desk numbers here ===
          this.customDesks = [
            114, 115, 116, 117, 118, 119, 149, 150, 151, 152, 153, 154, 155,
            156, 157, 158, 159, 160,
          ];

          // Precompute allowed set
          this.allowedDesks = this.buildAllowedDeskSet();

          this.pollInterval = null;
          this.init();
        }

        buildAllowedDeskSet() {
          const set = new Set();

          // Add range desks
          for (let i = this.startDesk; i <= this.endDesk; i++) {
            set.add(String(i));
            set.add(`DESK${i}`);
            set.add(`desk${i}`);
          }

          // Add custom desks
          for (const d of this.customDesks) {
            set.add(String(d));
            set.add(`DESK${d}`);
            set.add(`desk${d}`);
          }

          return set;
        }

        getDeskNumber(order) {
          const d = order?.desk != null ? String(order.desk).trim() : "";
          if (/^\d+$/.test(d)) return parseInt(d, 10);

          const sa =
            order?.serviceArea != null ? String(order.serviceArea).trim() : "";
          const m = sa.match(/desk\s*([0-9]+)/i);
          if (m) return parseInt(m[1], 10);

          return null;
        }

        isDeskInAllowedRange(order) {
          const n = this.getDeskNumber(order);
          if (n != null) {
            return (
              (n >= this.startDesk && n <= this.endDesk) ||
              this.customDesks.includes(n)
            );
          }

          // fallback string check
          const d = order?.desk != null ? String(order.desk).trim() : "";
          const sa =
            order?.serviceArea != null ? String(order.serviceArea).trim() : "";
          return this.allowedDesks.has(d) || this.allowedDesks.has(sa);
        }

        getOrdersInRange() {
          return this.orders.filter((o) => this.isDeskInAllowedRange(o));
        }

        init() {
          this.loadOrders();
          this.attachEventListeners();
          this.startPolling();
          this.updateStats();
        }

        attachEventListeners() {
          document
            .getElementById("statusFilter")
            .addEventListener("change", () => this.filterOrders());
          document
            .getElementById("deskFilter")
            .addEventListener("input", () => this.filterOrders());
          document
            .getElementById("refreshBtn")
            .addEventListener("click", () => this.loadOrders());
          document
            .getElementById("clearBtn")
            .addEventListener("click", () => this.clearAllOrders());
        }

        startPolling() {
          this.pollInterval = setInterval(() => {
            this.loadOrders(false);
          }, 3000);
        }

        async loadOrders(silent = false) {
          try {
            const res = await fetch(this.apiEndpoint);
            if (!res.ok)
              throw new Error(`GET /api/orders failed: ${res.status}`);
            const newOrders = await res.json();
            this.handleOrdersUpdate(newOrders, silent);
          } catch (error) {
            console.warn("API not available, loading from localStorage", error);
            const localOrders = JSON.parse(
              localStorage.getItem("dashboardOrders") || "[]"
            );
            this.handleOrdersUpdate(localOrders, silent);
          }
        }

        handleOrdersUpdate(newOrders, silent) {
          const prevIds = new Set(this.orders.map((o) => String(o.id)));

          if (!this.firstLoad) {
            // only skip first load
            const newlyAddedInRange = [...newOrders]
              .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
              .find(
                (o) =>
                  !prevIds.has(String(o.id)) && this.isDeskInAllowedRange(o)
              );

            if (newlyAddedInRange) {
              const deskNum = this.getDeskNumber(newlyAddedInRange);
              const label =
                deskNum != null
                  ? `Desk #${deskNum}`
                  : newlyAddedInRange.desk ??
                    newlyAddedInRange.serviceArea ??
                    "-";
              this.showNotification(
                "New Order!",
                `Order received from ${label}`
              );
            }
          }

          this.orders = [...newOrders].sort(
            (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
          );
          this.filterOrders();
          this.updateStats();

          this.firstLoad = false; // 👈 mark first load done
        }

        filterOrders() {
          const statusFilter = document.getElementById("statusFilter").value;
          const deskFilter = document.getElementById("deskFilter").value;

          // Always start from in-range orders
          const base = this.getOrdersInRange();

          this.filteredOrders = base.filter((order) => {
            // ✅ Skip completed orders entirely
            if (order.status === "completed") return false;

            const statusMatch =
              statusFilter === "all" || order.status === statusFilter;

            const deskMatchInput =
              !deskFilter ||
              String(this.getDeskNumber(order) ?? order.desk) ===
                String(deskFilter);

            return statusMatch && deskMatchInput;
          });

          this.renderOrders();
        }

        renderOrders() {
          const ordersList = document.getElementById("ordersList");
          const ordersCount = document.getElementById("ordersCount");

          if (this.filteredOrders.length === 0) {
            ordersList.innerHTML = `
                <div class="empty-state">
                  <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 7h-3V6a4 4 0 0 0-8 0v1H5a1 1 0 0 0-1 1v11a3 3 0 0 0 3 3h10a3 3 0 0 0 3-3V8a1 1 0 0 0-1-1ZM10 6a2 2 0 0 1 4 0v1h-4V6Zm8 13a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V9h2v1a1 1 0 0 0 2 0V9h4v1a1 1 0 0 0 2 0V9h2v10Z"/>
                  </svg>
                  <h3>No orders found</h3>
                  <p>Try adjusting your filters or wait for new orders</p>
                </div>`;
            ordersCount.textContent = "0 orders";
            return;
          }

          ordersCount.textContent = `${this.filteredOrders.length} order${
            this.filteredOrders.length !== 1 ? "s" : ""
          }`;

          ordersList.innerHTML = this.filteredOrders
            .map((order) => this.renderOrderCard(order))
            .join("");

          this.attachOrderActions();
        }

        renderOrderCard(order) {
          const formattedTime = new Date(order.timestamp).toLocaleString();
          const deskNum = this.getDeskNumber(order);
          const deskLabel =
            deskNum != null
              ? `Desk #${deskNum}`
              : order.desk
              ? `Desk #${order.desk}`
              : order.serviceArea
              ? order.serviceArea
              : "Desk";

          // 🔹 Group duplicate items
          const itemCounts = {};
          (order.items || []).forEach((item) => {
            itemCounts[item] = (itemCounts[item] || 0) + 1;
          });

          const itemsHtml = Object.entries(itemCounts)
            .map(
              ([name, count]) =>
                `<span class="item-tag">${name}${
                  count > 1 ? ` × ${count}` : ""
                }</span>`
            )
            .join("");

          return `
          <div class="order-card ${order.status}" data-order-id="${String(
            order.id
          )}">
            <div class="order-header">
              <div class="order-info">
                <div class="order-id">${deskLabel}</div>
                <div class="order-meta">
                  <span>📍 ${order.location ?? "-"}</span>
                  <span>🕐 ${formattedTime}</span>
                  <span>👥 ${order.serviceAreaName ?? "-"}</span>
                </div>
              </div>
              <div class="order-status ${order.status}">
                ${order.status.replace("-", " ")}
              </div>
            </div>
            <div class="order-items">
              <div class="items-title">Items Ordered:</div>
              <div class="items-list">
                ${itemsHtml}
              </div>
            </div>
            ${
              order.orderNote
                ? `
              <div class="order-note-display">
                <strong>Note:</strong> ${order.orderNote}
              </div>
            `
                : ""
            }
            <div class="order-actions">
              ${
                order.status === "pending"
                  ? '<button class="action-btn start-btn" data-action="start">Start Order</button>'
                  : ""
              }
              ${
                order.status === "in-progress"
                  ? '<button class="action-btn complete-btn" data-action="complete">Mark Complete</button>'
                  : ""
              }
              <button class="action-btn delete-btn" data-action="delete">Delete Order</button>
            </div>
          </div>
        `;
        }

        attachOrderActions() {
          const list = document.getElementById("ordersList");
          list.onclick = null;
          list.addEventListener("click", (e) => {
            const btn = e.target.closest(".action-btn");
            if (!btn) return;
            const card = e.target.closest(".order-card");
            if (!card) return;
            const orderId = card.dataset.orderId;
            const action = btn.dataset.action;
            this.handleOrderAction(orderId, action);
          });
        }

        async handleOrderAction(orderId, action) {
          const order = this.orders.find(
            (o) => String(o.id) === String(orderId)
          );
          if (!order || !this.isDeskInAllowedRange(order)) return; // safety

          try {
            if (action === "start") {
              order.status = "in-progress";
              this.filterOrders();
              this.updateStats();

              const res = await fetch(
                `${this.apiEndpoint}/${encodeURIComponent(orderId)}`,
                {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ status: "in-progress" }),
                }
              );
              if (!res.ok) throw new Error(`PUT failed: ${res.status}`);
            } else if (action === "complete") {
              order.status = "completed";
              this.filterOrders();
              this.updateStats();

              const res = await fetch(
                `${this.apiEndpoint}/${encodeURIComponent(orderId)}`,
                {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({ status: "completed" }),
                }
              );
              if (!res.ok) throw new Error(`PUT failed: ${res.status}`);
            } else if (action === "delete") {
              if (!confirm("Are you sure you want to delete this order?"))
                return;

              this.orders = this.orders.filter(
                (o) => String(o.id) !== String(orderId)
              );
              this.filterOrders();
              this.updateStats();

              const res = await fetch(
                `${this.apiEndpoint}/${encodeURIComponent(orderId)}`,
                { method: "DELETE" }
              );
              if (!res.ok) throw new Error(`DELETE failed: ${res.status}`);
            }

            await this.loadOrders(true);
          } catch (err) {
            console.error("Action failed:", err);
            // this.showNotification(
            //   "Error",
            //   "Failed to update order. Check console."
            // );
            this.loadOrders(true);
          }
        }

        // Keep bulk save for other uses (unchanged)
        async saveOrders() {
          try {
            const response = await fetch(`${this.apiEndpoint}/bulk`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(this.orders),
            });
            if (!response.ok) throw new Error("API bulk save failed");
          } catch (error) {
            console.warn("API not available, saving to localStorage");
            localStorage.setItem(
              "dashboardOrders",
              JSON.stringify(this.orders)
            );
          }
        }

        updateStats() {
          const inRange = this.getOrdersInRange();
          const total = inRange.length;
          const pending = inRange.filter((o) => o.status === "pending").length;
          const inProgress = inRange.filter(
            (o) => o.status === "in-progress"
          ).length;

          const today = new Date().toDateString();
          const completedToday = inRange.filter(
            (o) =>
              o.status === "completed" &&
              new Date(o.timestamp).toDateString() === today
          ).length;

          // document.getElementById("totalOrders").textContent = total;
          // document.getElementById("pendingOrders").textContent = pending;
          // document.getElementById("inProgressOrders").textContent = inProgress;
          // document.getElementById("completedOrders").textContent =
          //   completedToday;
        }

        // Now clears ONLY the orders within the allowed desk range
        async clearAllOrders() {
          if (
            !confirm(
              `Delete all orders for desks ${this.startDesk}-${this.endDesk}? This cannot be undone.`
            )
          ) {
            return;
          }

          try {
            const inRange = this.getOrdersInRange();
            const ids = inRange.map((o) => o.id);

            // Optimistic local removal
            const idSet = new Set(ids.map(String));
            this.orders = this.orders.filter((o) => !idSet.has(String(o.id)));
            this.filterOrders();
            this.updateStats();

            // Persist each deletion
            const results = await Promise.allSettled(
              ids.map((id) =>
                fetch(`${this.apiEndpoint}/${encodeURIComponent(id)}`, {
                  method: "DELETE",
                })
              )
            );

            const allOk = results.every(
              (r) => r.status === "fulfilled" && r.value?.ok
            );

            if (!allOk) throw new Error("One or more deletes failed");

            this.showNotification(
              "Success",
              `Cleared orders for desks ${this.startDesk}-${this.endDesk}`
            );
          } catch (error) {
            console.error(error);
            // this.showNotification(
            //   "Error",
            //   "Failed to clear orders. See console."
            // );
            this.loadOrders(true);
          }
        }

        showNotification(title, message) {
          const el = document.getElementById("notification");
          document.getElementById("notificationTitle").textContent = title;
          document.getElementById("notificationMessage").textContent = message;
          el.classList.add("show");

          const sound = document.getElementById("notificationSound");
          if (sound) {
            sound.pause();
            sound.currentTime = 0;
            sound
              .play()
              .catch((err) => console.warn("Autoplay prevented:", err));
          }

          setTimeout(() => el.classList.remove("show"), 4000);
        }

        destroy() {
          if (this.pollInterval) clearInterval(this.pollInterval);
        }
      }

      let dashboard;
      document.addEventListener("DOMContentLoaded", () => {
        dashboard = new DashboardApp();
      });
      window.addEventListener("beforeunload", () => {
        if (dashboard) dashboard.destroy();
      });
    </script>
  </body>
</html>
