<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ðŸ“Š Order Statistics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, sans-serif;
        background: #f4f6f9;
        margin: 0;
        padding: 20px;
        color: #333;
      }

      h1 {
        text-align: center;
        margin-bottom: 30px;
        color: #222;
        font-size: 28px;
      }

      .stats-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 20px;
        margin-bottom: 40px;
      }

      .stat-card {
        background: #fff;
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        text-align: center;
        transition: transform 0.2s ease;
      }

      .stat-card:hover {
        transform: translateY(-4px);
      }

      .stat-card h2 {
        margin: 10px 0;
        color: #007bff;
        font-size: 28px;
      }

      .stat-card p {
        margin: 0;
        font-size: 14px;
        color: #666;
      }

      .charts-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      canvas {
        background: #fff;
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }

      .stars {
        color: gold;
        font-size: 20px;
      }

      /* âœ… Chart section layout */
      .chart-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 40px;
      }

      .chart-box {
        background: #fff;
        padding: 20px;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
      }

      /* âœ… Proportionate Bar Chart (16:9 look, centered) */
      #avgTimeByTeaboy {
        width: 100%;
        max-width: 900px; /* prevents it from being too wide */
        aspect-ratio: 16 / 9;
      }

      /* âœ… Centered Pie Chart (square, proportional) */
      #ordersByTeaboy {
        width: 360px;
        height: 360px;
      }

      @media (max-width: 768px) {
        #avgTimeByTeaboy {
          max-width: 100%;
          aspect-ratio: 4 / 3;
        }
        #ordersByTeaboy {
          width: 280px;
          height: 280px;
        }
      }
    </style>
  </head>
  <body>
    <h1>ðŸ“Š Order Statistics Dashboard</h1>

    <div class="stats-container">
      <div class="stat-card">
        <h2 id="totalOrders">0</h2>
        <p>Total Orders</p>
      </div>
      <div class="stat-card">
        <h2 id="completedOrders">0</h2>
        <p>Completed Orders</p>
      </div>
      <div class="stat-card">
        <h2 id="avgPrepTime">0 min</h2>
        <p>Average Preparation Time</p>
      </div>
      <div class="stat-card">
        <h2 id="avgRating">0 â˜…</h2>
        <div id="avgStars" class="stars"></div>
        <p>Average Rating</p>
      </div>
    </div>

    <div class="charts-container">
      <canvas id="ordersByDate"></canvas>

      <div class="chart-section">
        <div class="chart-box">
          <canvas id="avgTimeByTeaboy"></canvas>
        </div>
        <div class="chart-box" style="max-width: 420px">
          <canvas id="ordersByTeaboy"></canvas>
        </div>
      </div>
    </div>

    <script nonce="123456">
      // Helper: safe parse date
      function parseDateSafe(value) {
        if (!value) return null;
        const d = new Date(value);
        return isNaN(d.getTime()) ? null : d;
      }

      // Chart holders so we can destroy when redrawing (avoid overlaps)
      let ordersByDateChart = null;
      let ordersByTeaboyChart = null;
      let avgTimeByTeaboyChart = null;

      async function loadStats() {
        // fetch raw orders and compute everything client-side for last 30 days
        const res = await fetch("/api/orders?company=remat", {
          cache: "no-store",
        });
        const allOrders = (await res.json()) || [];

        // compute cutoff (start of period)
        const now = new Date();
        const cutoff = new Date(now);
        cutoff.setDate(now.getDate() - 30);
        cutoff.setHours(0, 0, 0, 0); // inclusive from that day start

        // filter orders to last 30 days based on timestamp
        const orders = allOrders.filter((o) => {
          const t = parseDateSafe(o.timestamp);
          return t && t >= cutoff && t <= now;
        });

        // total / completed counts (within last 30 days)
        const totalOrders = orders.length;
        const completedOrders = orders.filter(
          (o) => o.status === "completed"
        ).length;

        // avgPrepTime: average of completed orders that have valid startedAt & completedAt
        const prepTimes = orders
          .filter((o) => o.status === "completed")
          .map((o) => {
            const s = parseDateSafe(o.startedAt);
            const e = parseDateSafe(o.completedAt);
            if (!s || !e) return null;
            const mins = (e.getTime() - s.getTime()) / 60000;
            return Number.isFinite(mins) ? mins : null;
          })
          .filter((v) => v !== null);

        const avgPrepTime = prepTimes.length
          ? prepTimes.reduce((a, b) => a + b, 0) / prepTimes.length
          : 0;

        // avgRating: average of rating.stars for orders in the period (if present)
        const ratings = orders
          .filter((o) => o.rating && typeof o.rating.stars === "number")
          .map((o) => Number(o.rating.stars));

        const avgRating = ratings.length
          ? ratings.reduce((a, b) => a + b, 0) / ratings.length
          : 0;

        // ordersByDate: group by local date string (last 30 days only)
        const ordersByDate = {};
        orders.forEach((o) => {
          const t = parseDateSafe(o.timestamp);
          if (!t) return;
          const key = t.toLocaleDateString();
          ordersByDate[key] = (ordersByDate[key] || 0) + 1;
        });

        // ordersByTeaboy: counts of orders (any status) per teaboy in last 30 days
        const ordersByTeaboy = {};
        orders.forEach((o) => {
          const name = (o.teaboyName || o.serviceAreaName || "Unknown") + "";
          const key = name.trim() || "Unknown";
          ordersByTeaboy[key] = (ordersByTeaboy[key] || 0) + 1;
        });

        // avgTimeByTeaboy: for each teaboy compute avg = sum(valid timed durations) / number_of_valid_timed_orders
        // (conventional average â€” only timed completed orders contribute)
        const sumMinutesPerTeaboy = {};
        const validCountPerTeaboy = {};

        orders.forEach((o) => {
          if (o.status !== "completed") return;
          const name = (o.teaboyName || o.serviceAreaName || "Unknown") + "";
          const key = name.trim() || "Unknown";
          const s = parseDateSafe(o.startedAt);
          const e = parseDateSafe(o.completedAt);
          if (s && e) {
            const mins = (e.getTime() - s.getTime()) / 60000;
            if (Number.isFinite(mins)) {
              sumMinutesPerTeaboy[key] = (sumMinutesPerTeaboy[key] || 0) + mins;
              validCountPerTeaboy[key] = (validCountPerTeaboy[key] || 0) + 1;
            }
          }
        });

        const avgTimeByTeaboy = {};
        Object.keys(ordersByTeaboy).forEach((teaboy) => {
          const sumMins = sumMinutesPerTeaboy[teaboy] || 0;
          const validCount = validCountPerTeaboy[teaboy] || 0;
          // if we have valid timed orders, divide by validCount; otherwise 0
          const avg = validCount > 0 ? sumMins / validCount : 0;
          avgTimeByTeaboy[teaboy] = parseFloat(avg.toFixed(1));
        });

        // ---------------- Update DOM stats (all values are for last 30 days) ----------------
        document.getElementById("totalOrders").textContent = totalOrders;
        document.getElementById("completedOrders").textContent =
          completedOrders;
        document.getElementById("avgPrepTime").textContent =
          avgPrepTime.toFixed(1) + " min";
        document.getElementById("avgRating").textContent =
          avgRating.toFixed(1) + " â˜…";

        const stars = Math.round(avgRating || 0);
        document.getElementById("avgStars").textContent =
          "â˜…".repeat(stars) + "â˜†".repeat(5 - stars);

        // ---------------- Charts ----------------
        // destroy previous charts if any
        try {
          if (ordersByDateChart) ordersByDateChart.destroy();
        } catch (e) {}
        try {
          if (ordersByTeaboyChart) ordersByTeaboyChart.destroy();
        } catch (e) {}
        try {
          if (avgTimeByTeaboyChart) avgTimeByTeaboyChart.destroy();
        } catch (e) {}

        // Orders by Date (sorted chronologically)
        const dateLabels = Object.keys(ordersByDate).sort(
          (a, b) => new Date(a) - new Date(b)
        );
        const dateCounts = dateLabels.map((d) => ordersByDate[d]);

        const ctxDate = document
          .getElementById("ordersByDate")
          .getContext("2d");
        ordersByDateChart = new Chart(ctxDate, {
          type: "line",
          data: {
            labels: dateLabels,
            datasets: [
              {
                label: "Orders per Day (Last 30 Days)",
                data: dateCounts,
                borderColor: "#007bff",
                backgroundColor: "rgba(0,123,255,0.2)",
                tension: 0.3,
                fill: true,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: { label: (ctx) => `${ctx.parsed.y} orders` },
              },
            },
            scales: {
              x: {
                ticks: { color: "#555" },
                title: {
                  display: true,
                  text: "Date (last 30 days)",
                  color: "#333",
                },
              },
              y: {
                ticks: { color: "#555" },
                title: {
                  display: true,
                  text: "Number of Orders",
                  color: "#333",
                },
                beginAtZero: true,
              },
            },
          },
        });

        // Teaboy labels (use union of keys so both charts align even if some teaboys don't have timed orders)
        const teaboyLabels = Array.from(
          new Set([
            ...Object.keys(ordersByTeaboy),
            ...Object.keys(avgTimeByTeaboy),
          ])
        );

        // colors palette (reusable)
        const basePalette = [
          "#007bff",
          "#28a745",
          "#ffc107",
          "#dc3545",
          "#6f42c1",
          "#17a2b8",
          "#fd7e14",
          "#20c997",
          "#6610f2",
          "#e83e8c",
        ];
        const colors = teaboyLabels.map(
          (_, i) => basePalette[i % basePalette.length]
        );

        // Orders by Teaboy (pie)
        const teaboyCounts = teaboyLabels.map((l) => ordersByTeaboy[l] || 0);
        const ctxPie = document
          .getElementById("ordersByTeaboy")
          .getContext("2d");
        ordersByTeaboyChart = new Chart(ctxPie, {
          type: "pie",
          data: {
            labels: teaboyLabels,
            datasets: [
              { data: teaboyCounts, backgroundColor: colors, borderWidth: 1 },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: "right",
                labels: { boxWidth: 15, color: "#333" },
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => `${ctx.label}: ${ctx.parsed} orders`,
                },
              },
            },
            maintainAspectRatio: false,
          },
        });

        // Avg time by teaboy (bar) â€” match label order and colors
        const avgTimes = teaboyLabels.map((l) => avgTimeByTeaboy[l] || 0);
        const ctxBar = document
          .getElementById("avgTimeByTeaboy")
          .getContext("2d");
        avgTimeByTeaboyChart = new Chart(ctxBar, {
          type: "bar",
          data: {
            labels: teaboyLabels,
            datasets: [
              {
                label: "Average Preparation Time (minutes)",
                data: avgTimes,
                backgroundColor: colors
                  .map((c) => c.replace("#", "rgba("))
                  .map((c, idx) => {
                    // create semi-transparent rgb from hex
                    const hex = basePalette[idx % basePalette.length];
                    const r = parseInt(hex.slice(1, 3), 16),
                      g = parseInt(hex.slice(3, 5), 16),
                      b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r},${g},${b},0.6)`;
                  }),
                borderColor: colors,
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => `${parseFloat(ctx.parsed.y).toFixed(1)} min`,
                },
              },
            },
            scales: {
              x: {
                ticks: { color: "#555" },
                title: { display: true, text: "Teaboy", color: "#333" },
              },
              y: {
                beginAtZero: true,
                ticks: { color: "#555" },
                title: {
                  display: true,
                  text: "Average Time (minutes)",
                  color: "#333",
                },
              },
            },
            maintainAspectRatio: false,
          },
        });
      }

      // initial load
      loadStats();
    </script>
  </body>
</html>
